#include <iostream>
using namespace std;
/*
Pointer
- 포인터는 주소를 저장한다.
- 모든 데이터는 메모리상에 특정한 공간에 저장되어 있음
- 기존의 우리가 알고있는 변수는 데이터를 저장하지만 포인터는 메모리 공간의 주소를 저장한다.
- 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야함.
ㄴ변수이름 앞에 &연산자를 붙이면 해당 변수의 시작주소를 반환한다.
- 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조하려면 *연산자를 사용한다.

& : 특정한 데이터의 메모리 상의 주소값을 알 수 있다.
* : &연산자가 어떤 데이터의 주소값을 얻어내는 연산자라면 주소값에서 해당 주소값에 대응되는 데이터를 가져온다.
 
 포인터 변수는 주소만 저장하는 녀석이라며?
 근데 왜 타입이 있음?

 시작주소만 읽는데 얼마나 읽어줘야 할지 모르기 때문에 타입이 존재
 int num;
 pointer(라는 타입이 있다고 가정할때)*p;
 p = &num;
 */
/*
const (절대로 값이 바뀌지않을것같거나 바뀌면안되는 녀석에게 붙임)

*/

void main()
{
 
  
    int* p;//포인터 변수 p선언

    int a = 2;
    p = &a;//변수a 의 주소를 저장
    cout << "p의 값 (변수 a의 주소값) : " << p << endl;
    cout << a << endl;
    cout << "*p의 값 : " << *p << endl;
    *p = 100;
    cout << "변경후 : *p의 값(a의 값) : " << *p << endl;
  
    //int num;
    //const int* pa = &num;
    //int b;
    //const int*
    ///*
    //    const int형 변수를 가르키는 것이 아니라
    //    int형 변수를 가리키는데 그 값을 절대로 바꾸지 말라는 뜻
    //    즉, pa는 어떤 int형 변수를 가리키고 있고 const가 붙어있기 때문에
    //    pa가 가리키는 변수의 값은 절대로 바뀌면 안된다는 뜻이다.
    //
    //*/
    //*pa = 3; //error
    //pa = &b; //ok

    int a;
    int b;
    //const int* 실제 데이터를 상수화
    //int* const 데이터의 주소를 상수화
    int* const pa = &a;
    *pa = 3; //ok
    pa = &b; //error
    //ㄴpa의 값이 바뀌면 안된다는 것.
    //위에서는 a의 주소를 저장
    //pa는 절대적으로 바뀌면 안되지만  b의 주소를 담으려고 했기때문에 error
  
  
  
  
  
  
  
  

  










}